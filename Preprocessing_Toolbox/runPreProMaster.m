%runPrePro Runs data pre-preprocessing
%
%This preprocessing toolbox was created to minimize the effort of
%preprocessing two-photon calcium data and was created by Jorrit Montijn at
%the University of Amsterdam
%
%To finish all pre-processing steps, you should run the following scripts
%in order:
%
%(1) runPreProMaster
%	Use this function to pre-preprocess data; this includes meta data
%	retrieval (doPrePro), image processing (doImagePrePro) and pixel-based
%	stimulus response maps (doCalcPixelResponsiveness)
%(2) runDetectCells
%	This function is used to select regions of interest based on the
%	average images generated by the previous step; it includes broad
%	functionality including neuronal subtype differentation based on 960nm
%	reference images, pixel-based responsiveness maps, 
%	retrieval (doPrePro), image processing (doImagePrePro) and pixel-based
%	stimulus response maps (doCalcPixelResponsiveness), automatic border
%	detection for OGB and GCaMP, and across-recording alignment functions,
%	such as the custom-built automatic recursive locally affine subfield
%	reregistration algorithm (by JM), ROI shift detection, etc.
%(3) runPostDetectionMaster
%	This function runs all post-preprocessing steps consecutively for the
%	defined session/recordings; this includes the following steps:
%	runImageToTimeseries to extract fluorescence time traces from the image
%	data for all ROIs defined in the previous step;
%	runDetectCalciumTransients to calculate dF/F0 values from these traces
%	and detect spikes from the calcium transient data; and
%	runBuildSesFromPrePro to transform the preprocessing data format to a
%	more useable "ses" data format on which all data processing functions
%	are based
%(4) Optional: eye-tracking video analysis and Z-drift checking
%	(runDriftChecker/runAcrossRecordingDriftChecker) to confirm z-stability
%	of your recordings 
%
%	Version history:
%	1.0 - September 14 2012
%	Created by Jorrit Montijn
%	2.0 - May 16 2014
%	Updated help & comments [by JM]


% the input data structure should be as follows:
%[Session] ('YYYYMMDD')
%	[Recording] ('xyt01')
%		[t] ('163') 
%			[z] ('1')
%				[ch] ('2')
%					FrameXY ('[session]\[recording]\[recording]_t0001_ch00.tif')
% the XML file should be named [recording]_Properties.xml and should be
% present in either \[session]\[recording]\ or
% [session]\[recording]\MetaData\

%{
data structure PER RECORDING:
sRec = struct;

sRec.sPS = sPS;

sRec.sMD = sMD;

sRec.strSession = 'YYYYMMDD';
sRec.vecRecordings = [1 2 3 4 5];
sRec.intRecording = 4;

sRec.xml = struct;

sRec.sRawLog = struct;

sRec.sRawLib = struct;
sRec.sRawLib.strRecording = 'xyt01';
sRec.sRawLib.strName = 'VisualStimulation_JOB010';
sRec.sRawLib.strStimLog
sRec.sRawLib.t = 2376;
sRec.sRawLib.z = 1;
sRec.sRawLib.x = 512;
sRec.sRawLib.y = 512;

sRec.sProcLib = struct;
sRec.sProcLib.strRecording = sRec.sPS.strRecording{sRec.intRecording};
sRec.sProcLib.strName = sRec.sProcLib.strRecording;
sRec.sProcLib.t = 2376;
sRec.sProcLib.z = 1;
sRec.sProcLib.x = 512;
sRec.sProcLib.y = 512;

sRec.sProcLog = struct; %processing log
sRec.sProcLog.boolTempPresent = false;
sRec.sProcLog.boolDefaultFound = false;
sRec.sProcLog.boolXMLFound = false;
sRec.sProcLog.boolStimLogFound = false;
sRec.sProcLog.boolTestLoaded = false;
sRec.sProcLog.boolRawLibPresent = false;
sRec.sProcLog.boolProcLibPresent = false;
sRec.sProcLog.boolPhaseCorrected = false;
sRec.sProcLog.boolSmoothed = false;
sRec.sProcLog.boolRegistered = false;
sRec.sProcLog.boolAverageSaved = false;
%}
	
%% load default settings
%clear all;
sPS = loadDefaultSettingsPrePro();%structProcessingSettings
sPS.boolSupervised = false; %is there anyone overseeing the process? or should it just run without asking input?

%% define general metadata
sMD = struct; %structMetaData
sMD.strMasterDir = 'D:\Data';
sMD.strSourceDir = 'G:\Data';
sMD.strImgSource = '\Raw\imagingdata\';
sMD.strLogSource = '\Raw\imaginglogs\';
sMD.strImgTarget = '\Processed\imagingdata\';
sMD.strLogTarget = '\Processed\imaginglogs\';
sMD.strTemp = '\Temp\';

%% define specific recording
%{
	cellSes{1}= '20140129';
	cellRec{1}= 'xyt01';
	
	cellSes{2}= '20140129';
	cellRec{2}= 'xyt02';
	
	cellSes{3}= '20140129';
	cellRec{3}= 'xyt03';
	
	cellSes{4}= '20140129';
	cellRec{4}= 'xyt04';
	
	cellSes{5}= '20140129';
	cellRec{5}= 'xyt05';
	
	cellSes{6}= '20121207';
	cellRec{6}= 'xyt02';
%}
if ~exist('strSession','var')
	strSession = '20140604';
	vecRecordings = 1:5;
end
%if ~exist('strSession','var')
%	strSession = '20140423';
%	vecRecordings = 1:3;
%end

%assign filenames
for intRec=vecRecordings
	cellName{intRec} = sprintf('xyt%02d',intRec);
	cellRefPaths{intRec} =[sMD.strSourceDir sMD.strImgSource strSession filesep cellName{intRec} filesep];
end
cellStimLog{1} = '20140604_MP_Lick_Water_HeadFixed_StimDetection_M56_xyt01_setup0.mat'; %name of the stimulation log
cellStimLog{2} = '20140604_MP_Lick_Water_HeadFixed_StimDetection_M56_xyt02_setup0.mat';
cellStimLog{3} = '20140604_MP_Lick_Water_HeadFixed_StimDetection_M56_xyt03_setup0.mat';
cellStimLog{4} = '20140604_MP_Lick_Water_HeadFixed_StimDetection_M56_xyt04_setup0.mat';
cellStimLog{5} = '20140604_MP_Lick_Water_HeadFixed_StimDetection_M56_xyt05_setup0.mat';
%cellStimLog{6} = '20140530_MP_Lick_Water_HeadFixed_StimDetection_M55_xyt06_setup0.mat';
%cellStimLog{7} = '20140530_MP_Lick_Water_HeadFixed_StimDetection_M55_xyt07_setup0.mat';
%cellStimLog{8} = '20140530_MP_Lick_Water_HeadFixed_StimDetection_M55_xyt08_setup0.mat';
%cellStimLog{9} = '20140530_MP_OrientationTuning8BiDirections_M55_xyt09.mat';
%end

%% collect metadata for recordings
multiStruct = struct;
for intRecording=vecRecordings
	%define variables for every recording
	sRec = struct;
	sRec.sPS = sPS;
	sRec.sMD = sMD;
	sRec.strSession = strSession;
	sRec.vecRecordings = vecRecordings;
	sRec.intRecording = intRecording;
	sRec.sRawLib = struct;
	sRec.sRawLib.strRecording = cellName{intRecording}; %directory
	sRec.sRawLib.strName = cellName{intRecording}; %file name header
	sRec.sRawLib.strStimLog = cellStimLog{intRecording}; %name of the stimulation log
	%sRec.sRawLib.strRefIm = cellRefIms{intRecording}; %name of reference registration image (if different from the data set itself)
	sRec.sRawLib.strRefPath = cellRefPaths{intRecording}; %name of reference registration image path
	sRec = doPrePro(sRec);
	multiStruct.sRec(intRecording) = sRec;
	clear sRec;
end

%% do actual image processing & perform pixel responsiveness analysis
for intRecording=vecRecordings
	fprintf('\nProceeding with image processing of recording %d... Please be patient, this could take a while.\n',intRecording)
	sRec = multiStruct.sRec(intRecording);
	sRec = doImagePrePro(sRec);
	sRec = doCalcPixelResponsiveness(sRec);
	multiStructOut.sRec(intRecording) = sRec;
end
